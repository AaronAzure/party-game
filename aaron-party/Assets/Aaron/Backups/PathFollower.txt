using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class PathFollower : MonoBehaviour
{
    // GLOBAL VARIABLES
    [Header("Data to save across Scenes")]
    private Node[] _currentPath;                    // CURRENT NODE(PATH)
    private int _currentNode;                       // INDEX OF THE CURRENT SPACE ON NODE(PATH)
    private Vector3 _currentPositionHolder;         // POSITION OF THE CURRENT SPACE

    [Header("Custom Paths")]
    private GameObject   _path0;
    private Node[]      _nodes0;
    private GameObject   _path1;
    private Node[]      _nodes1;
    private GameObject   _path2;
    private Node[]      _nodes2;
    private GameObject   _path3;
    private Node[]      _nodes3;
    private GameObject   _path4;
    private Node[]      _nodes4;
    private GameObject   _path5;
    private Node[]      _nodes5;
    private GameObject   _path6;
    private Node[]      _nodes6;
    private GameObject   _path7;
    private Node[]      _nodes7;
    private GameObject   _path8;
    private Node[]      _nodes8;
    private GameObject   _path9;
    private Node[]      _nodes9;
    private GameObject   _path10;
    private Node[]      _nodes10;
    private GameObject   _path11;
    private Node[]      _nodes11;
    private GameObject   _path12;
    private Node[]      _nodes12;
    private GameObject   _path13;
    private Node[]      _nodes13;
    private GameObject   _path14;
    private Node[]      _nodes14;
    private GameObject   _path15;
    private Node[]      _nodes15;


    private int _movesRemaining;
    [SerializeField] private SpriteRenderer _movesSprite;
    [SerializeField] private Sprite[] _howManyMovesRemaining;

    [Header("Player Settings")]
    [SerializeField] private float _moveSpeed;      // SPEED TO MOVE TO NEXT SPACE
    private float _timer;                           // 

    [SerializeField] private GameManager _gm;
    [SerializeField] private Camera _cam;           // PLAYER TRACKING CAM
    private float transitionTime = 0.5f;
    [SerializeField] private GameObject _choice;    // VISUAL INDICATING WHICH WAY TO GO
    private bool _pathChosen = true;                // HAS CHOSEN A PATH

    private BoxCollider2D _collider;
    private string _currentScene;
    private bool _readyToMove = false;
    private bool _isPlayerTurn = false;

    private bool _haveMovedAside = false;
    private Vector3 asidePos1;
    private Vector3 asidePos2;
    private Vector3 asidePos3;
    private Vector3 asidePos4;
    private Vector3 asidePos5;
    private Vector3 asidePos6;
    private Vector3 asidePos7;
    private Vector3 asidePos8;

    [Header("etc")]
    private GameController controller;


    // ---------------------------------------------------------------------

    // Start is called before the first frame update
    void Start()
    {
        controller = GameObject.Find("Game_Controller").GetComponent<GameController>();
        _gm = GameObject.Find("Game_Manager").GetComponent<GameManager>();
        _currentScene = SceneManager.GetActiveScene().name;
        _collider = this.transform.GetComponent<BoxCollider2D>();
        _collider.enabled = false;

        // GET PATHS (VARIOUS BETWEEN MAPS)
        if (GameObject.Find("Path_0") != null)
        {
            _path0 = GameObject.Find("Path_0");
            _nodes0 = _path0.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_1") != null)
        {
            _path1 = GameObject.Find("Path_1");
            _nodes1 = _path1.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_2") != null)
        {
            _path2 = GameObject.Find("Path_2");
            _nodes2 = _path2.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_3") != null)
        {
            _path3 = GameObject.Find("Path_3");
            _nodes3 = _path3.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_4") != null)
        {
            _path4 = GameObject.Find("Path_4");
            _nodes4 = _path4.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_5") != null)
        {
            _path5 = GameObject.Find("Path_5");
            _nodes5 = _path5.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_6") != null)
        {
            _path6 = GameObject.Find("Path_6");
            _nodes6 = _path6.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_7") != null)
        {
            _path7 = GameObject.Find("Path_7");
            _nodes7 = _path7.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_8") != null)
        {
            _path8 = GameObject.Find("Path_8");
            _nodes8 = _path8.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_9") != null)
        {
            _path9 = GameObject.Find("Path_9");
            _nodes9 = _path9.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_10") != null)
        {
            _path10 = GameObject.Find("Path_10");
            _nodes10 = _path10.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_11") != null)
        {
            _path11 = GameObject.Find("Path_11");
            _nodes11 = _path11.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_12") != null)
        {
            _path12 = GameObject.Find("Path_12");
            _nodes12 = _path12.GetComponentsInChildren<Node>();
        }
        if (GameObject.Find("Path_13") != null)
        {
            _path13 = GameObject.Find("Path_13");
            _nodes13 = _path13.GetComponentsInChildren<Node>();
        }


        if (controller.hasStarted)  // TURN 2+
        {
            // THE PATH THAT THE PLAYER IS TRAVERSING ACROSS (CONSTANT BETWEEN MAPS)
            switch (controller.GET_PATH_NODE(name))
            {
                case "Path_0":
                    _currentPath = _nodes0;
                    break;
                case "Path_1":
                    _currentPath = _nodes1;
                    break;
                case "Path_2":
                    _currentPath = _nodes2;
                    break;
                case "Path_3":
                    _currentPath = _nodes3;
                    break;
                case "Path_4":
                    _currentPath = _nodes4;
                    break;
                case "Path_5":
                    _currentPath = _nodes5;
                    break;
                case "Path_6":
                    _currentPath = _nodes6;
                    break;
                case "Path_7":
                    _currentPath = _nodes7;
                    break;
                case "Path_8":
                    _currentPath = _nodes8;
                    break;
                case "Path_9":
                    _currentPath = _nodes9;
                    break;
                case "Path_10":
                    _currentPath = _nodes10;
                    break;
                case "Path_11":
                    _currentPath = _nodes11;
                    break;
                case "Path_12":
                    _currentPath = _nodes12;
                    break;
                case "Path_13":
                    _currentPath = _nodes13;
                    break;
            }
            _currentNode = controller.GET_NODE_INDEX(name);
            _currentPositionHolder = controller.GET_POS_VECTOR(name);
            transform.position = controller.GET_END_POS(name);
            //transform.position = _currentPositionHolder;
        }
        else
        {
            // THE PATH THAT THE PLAYER IS TRAVERSING ACROSS (CONSTANT BETWEEN MAPS)
            _collider.enabled = true;
            _currentPath = _nodes0;
            _currentPositionHolder = _currentPath[_currentNode].transform.position + new Vector3(0, 1, 0);
        }

        _moveSpeed = 5;
        _choice.SetActive(false);
        _movesSprite.enabled = false;
        _haveMovedAside = false;
    }



    // START THE CAMERA BEFORE THE START OF THE FIRST TURN (NO ABRUPT TRANSTIONS)
    public void BEGIN()
    {
        _cam.gameObject.SetActive(true);
    }


    // CHECK NODE AND MOVE TO IT
    private void CHECK_NODE()
    {
        _timer = 0;
        
        if (_currentNode < _currentPath.Length)
        {
            _currentPositionHolder = _currentPath[_currentNode].transform.position + new Vector3(0, 1, 0);
            // PLAYER CAN MAKE NOISE WHEN GOING OVER SPACES
            if (!_collider.enabled) { _collider.enabled = true; }
        }
    }


    // DEBUG PATH LINES (SCENE VIEW EDITOR ONLY)
    private void DRAW_LINES()
    {
        for ( int i=0; i< _currentPath.Length-1; i++)
        {
            Debug.DrawLine(_currentPath[i].transform.position, _currentPath[i + 1].transform.position, Color.blue);
        }
    }


    // Update is called once per frame
    void Update()
    {
        if (_isPlayerTurn)
        {
            // THE PLAYER IS MOVING TO A NEW SPACE
            if (_movesRemaining > 0 && _readyToMove)
            {
                MOVE_PLAYER();
                UPDATE_MOVEMENT(_movesRemaining);
            }
            else
            {
                _currentPath[_currentNode].SPACE_LANDED();
                MOVE_ASIDE();
                // SPACE LANDED EFFECT
            }
        }

    }


    private void MOVE_PLAYER()
    {
        //DRAW_LINES();   // DEBUGGING
        _timer += _moveSpeed * Time.deltaTime;

        if (this.transform.position != _currentPositionHolder)
        {
            this.transform.position = Vector3.Lerp(this.transform.position, _currentPositionHolder, _timer);

            // THE PLAYER HAS MOVED A SPACE
            if (this.transform.position == _currentPositionHolder)
            {
                _movesRemaining--;
                //Debug.Log("Moves Left = " + _movesRemaining);
            }
        }
        else if (_currentNode < _currentPath.Length)        // MOVE TO NEXT NODE ON PATH
        {
            _currentNode++;
            CHECK_NODE();
        }

        // NEXT NODE IS EITHER A SPLIT PATH OR A CONJOINING PATH
        else if (_currentNode == _currentPath.Length)       // REACHED THE END OF A PATH
        {
            _choice.SetActive(true);
            _pathChosen = false;
            CHOOSE_PATH();
        }
    }

    // USER INPUT DIRECTIONS
    /*
    if (Input.GetKeyDown(KeyCode.LeftArrow))
    {
        _currentNode = 0;
        _currentPath = _nodes1;
        CHECK_NODE();
    }
    else if (Input.GetKeyDown(KeyCode.RightArrow))
    {
        _currentNode = 0;
        _currentPath = _nodes2;
        CHECK_NODE();
    }
    else if (Input.GetKeyDown(KeyCode.DownArrow))
    {
        _currentNode = 0;
        _currentPath = _nodes0;
        CHECK_NODE();
    }
    else if (Input.GetKeyDown(KeyCode.UpArrow))
    {
        _currentNode = 4;
        _currentPath = _nodes0;
        CHECK_NODE();
    }
    */


    // CHECK END OF PATHS BASED ON MAPS
    private void CHOOSE_PATH()
    {
        // CRYSTAL CAVERNS
        if (_currentScene == "Crystal_Caverns")
        {
            // END OF PATH 0
            if (_currentPath == _nodes0)
            {
                // MOVE TO PATH 1
                if (Input.GetKeyDown(KeyCode.RightArrow))
                {
                    _choice.SetActive(false); 
                    _currentNode = 0;
                    _currentPath = _nodes1;
                    CHECK_NODE(); 
                    _pathChosen = true;
                }
                // MOVE TO PATH 2
                else if (Input.GetKeyDown(KeyCode.UpArrow))
                {
                    _choice.SetActive(false);
                    _currentNode = 0;
                    _currentPath = _nodes2;
                    CHECK_NODE();
                    _pathChosen = true;
                }
            }
            // END OF PATH 1
            else if (_currentPath == _nodes1)            // FOLLOW PATH LOOP
            {
                _choice.SetActive(false);
                _currentNode = 0;
                _currentPath = _nodes3;
                CHECK_NODE();
                _pathChosen = true;
            }
            // END OF PATH 2
            else if (_currentPath == _nodes2)            // FOLLOW PATH LOOP
            {
                _choice.SetActive(false);
                _currentNode = 2;   // 3RD NODE
                _currentPath = _nodes0;
                CHECK_NODE();
                _pathChosen = true;
            }
            // END OF PATH 3
            else if (_currentPath == _nodes3)            // FOLLOW PATH LOOP
            {
                _choice.SetActive(false);
                _currentNode = 0;
                _currentPath = _nodes0;
                CHECK_NODE();
                _pathChosen = true;
            }

        }

        // OTHER MAPS
        if (_currentScene == "2P_Test")
        {
            if (_currentPath == _nodes0)                    // END OF PATH 1
            {
                // USER INPUT DIRECTION OF TRAVEL
                if (Input.GetKeyDown(KeyCode.RightArrow))
                {
                    _choice.SetActive(false);
                    _currentNode = 0;
                    _currentPath = _nodes3;
                    CHECK_NODE();
                }
                else if (Input.GetKeyDown(KeyCode.UpArrow))
                {
                    _choice.SetActive(false);
                    _currentNode = 0;
                    _currentPath = _nodes4;
                    CHECK_NODE();
                }
            }
            else if (_currentPath == _nodes1)            // FOLLOW PATH LOOP
            {
                _choice.SetActive(false);
                _currentNode = 0;
                _currentPath = _nodes0;
                CHECK_NODE();
            }
            else if (_currentPath == _nodes2)        // FOLLOW PATH LOOP
            {
                _choice.SetActive(false);
                _currentNode = 5 - 1;
                _currentPath = _nodes3;
                CHECK_NODE();
            }
            else if (_currentPath == _nodes3)           // FOLLOW PATH LOOP
            {
                _choice.SetActive(false);
                _currentNode = 0;
                _currentPath = _nodes5;
                CHECK_NODE();
            }
            else if (_currentPath == _nodes4)
            {
                if (Input.GetKeyDown(KeyCode.LeftArrow))
                {
                    _choice.SetActive(false);
                    _currentNode = 0;
                    _currentPath = _nodes1;
                    CHECK_NODE();
                }
                else if (Input.GetKeyDown(KeyCode.RightArrow))
                {
                    _choice.SetActive(false);
                    _currentNode = 0;
                    _currentPath = _nodes2;
                    CHECK_NODE();
                }
            }
            else if (_currentPath == _nodes5)           // CONTINUE OTHER PATH
            {
                _choice.SetActive(false);
                _currentNode = 3;
                _currentPath = _nodes1;
                CHECK_NODE();
            }
        }

        // RESUME SOUND EFFECTS
        if (_pathChosen)
        {
            StartCoroutine(WALK_OVER_SOUND_ON());
        }
    }

    private void UPDATE_MOVEMENT(int movesLeft)
    {
        _movesSprite.enabled = true;
        if (movesLeft <= _howManyMovesRemaining.Length)
        {
            _movesSprite.sprite = _howManyMovesRemaining[movesLeft];
        }
    }

    // MOVE PLAYER ASIDE FOR VISUAL INDICATION OF WHO'S ON WHAT SPACE
    private void MOVE_ASIDE()
    {
        float playerX = transform.position.x;
        float playerY = transform.position.y;
        float trig1 = 0.5f;
        float trig2 = 0.866f;
        if (!_haveMovedAside)   // CALL ONCE
        {
            _timer = 0;
            asidePos1 = new Vector3(playerX - trig2, playerY + trig1);
            asidePos2 = new Vector3(playerX - trig1, playerY + trig2);
            asidePos3 = new Vector3(playerX + trig1, playerY + trig2);
            asidePos4 = new Vector3(playerX + trig2, playerY + trig1);
            asidePos5 = new Vector3(playerX + trig2, playerY - trig1 + 0.5f);
            asidePos6 = new Vector3(playerX + trig1, playerY - trig2 + 0.5f);
            asidePos7 = new Vector3(playerX - trig1, playerY - trig2 + 0.5f);
            asidePos8 = new Vector3(playerX - trig2, playerY - trig1 + 0.5f);
            _haveMovedAside = true;
        }

        _timer += _moveSpeed * Time.deltaTime;

        // MOVE TO ASIDE POSITION
        switch (name)
        {
            case "Player_1":
                if (this.transform.position != asidePos1)
                {
                    this.transform.position = Vector3.Lerp(this.transform.position, asidePos1, _timer);
                }
                break;

            case "Player_2":
                if (this.transform.position != asidePos2)
                {
                    this.transform.position = Vector3.Lerp(this.transform.position, asidePos2, _timer);
                }
                break;

            case "Player_3":
                if (this.transform.position != asidePos3)
                {
                    this.transform.position = Vector3.Lerp(this.transform.position, asidePos3, _timer);
                }
                break;

            case "Player_4":
                if (this.transform.position != asidePos4)
                {
                    this.transform.position = Vector3.Lerp(this.transform.position, asidePos4, _timer);
                }
                break;

            case "Player_5":
                if (this.transform.position != asidePos5)
                {
                    this.transform.position = Vector3.Lerp(this.transform.position, asidePos5, _timer);
                }
                break;

            case "Player_6":
                if (this.transform.position != asidePos6)
                {
                    this.transform.position = Vector3.Lerp(this.transform.position, asidePos6, _timer);
                }
                break;

            case "Player_7":
                if (this.transform.position != asidePos7)
                {
                    this.transform.position = Vector3.Lerp(this.transform.position, asidePos7, _timer);
                }
                break;

            case "Player_8":
                if (this.transform.position != asidePos8)
                {
                    this.transform.position = Vector3.Lerp(this.transform.position, asidePos8, _timer);
                }
                break;
        }

        // END TURN
        switch (name)
        {
            case "Player_1":
                if (this.transform.position == asidePos1)
                {
                    StartCoroutine(TURN_FINISHED());
                }
                break;

            case "Player_2":
                if (this.transform.position == asidePos2)
                {
                    StartCoroutine(TURN_FINISHED());
                }
                break;

            case "Player_3":
                if (this.transform.position == asidePos3)
                {
                    StartCoroutine(TURN_FINISHED());
                }
                break;

            case "Player_4":
                if (this.transform.position == asidePos4)
                {
                    StartCoroutine(TURN_FINISHED());
                }
                break;

            case "Player_5":
                if (this.transform.position == asidePos5)
                {
                    StartCoroutine(TURN_FINISHED());
                }
                break;

            case "Player_6":
                if (this.transform.position == asidePos6)
                {
                    StartCoroutine(TURN_FINISHED());
                }
                break;

            case "Player_7":
                if (this.transform.position == asidePos7)
                {
                    StartCoroutine(TURN_FINISHED());
                }
                break;

            case "Player_8":
                if (this.transform.position == asidePos8)
                {
                    StartCoroutine(TURN_FINISHED());
                }
                break;
        }

    }

    // CAMERA FOCUSES ON PLAYER, WAIT BEFORE STARTING TURN
    public IEnumerator YOUR_TURN()
    {
        _readyToMove = true;
        if (controller.hasStarted)
        {
            // MOVE BACK (UNASIDE)
            transform.position = controller.GET_POS_VECTOR(name);   
        }
        _gm.StartCoroutine(_gm.MAIN_CAM_OFF());     // MAIN CAM OFF
        StartCoroutine(CAMERA_FADE_ON());           // PLAYER CAM ON
        _movesRemaining = Random.Range(5,6);   // DELETE
        _movesSprite.enabled = true;
        UPDATE_MOVEMENT(_movesRemaining);

        // WAIT BEFORE MOVING
        yield return new WaitForSeconds(transitionTime + 0.5f);

        _isPlayerTurn = true;           // PLAYER CAN MOVE
    }

    // CAMERA CHANGES, WAIT BEFORE ENDING TURN
    IEnumerator TURN_FINISHED()
    {
        _isPlayerTurn = false;
        _readyToMove = false;
        UPDATE_INFORMATION();

        yield return new WaitForSeconds(transitionTime + 0.5f);
        _movesSprite.enabled = false;
        StartCoroutine(CAMERA_FADE_OFF());          // PLAYER CAM OFF
        _gm.StartCoroutine(_gm.MAIN_CAM_ON());      // MAIN CAM ON
        _gm.INCREMENT_TURN();
    }

    IEnumerator CAMERA_FADE_ON()
    {
        yield return new WaitForSeconds(transitionTime);
        _cam.gameObject.SetActive(true);
    }
    IEnumerator CAMERA_FADE_OFF()
    {
        yield return new WaitForSeconds(transitionTime + 0.1f);
        _cam.gameObject.SetActive(false);
    }

    IEnumerator WALK_OVER_SOUND_ON()
    {
        yield return new WaitForSeconds(0.1f);
        _collider.enabled = true;
    }

    private void UPDATE_INFORMATION()
    {
        // STORE DATA ON THE PATH THE PLAYER IS CURRENTLY ON
        if (_currentPath == _nodes0)
        {
            controller.SET_PATH_NODE(name,"Path_0");
        }
        else if (_currentPath == _nodes1)
        {
            controller.SET_PATH_NODE(name, "Path_1");
        }
        else if (_currentPath == _nodes2)
        {
            controller.SET_PATH_NODE(name, "Path_2");
        }
        else if (_currentPath == _nodes3)
        {
            controller.SET_PATH_NODE(name, "Path_3");
        }
        else if (_currentPath == _nodes4)
        {
            controller.SET_PATH_NODE(name, "Path_4");
        }
        else if (_currentPath == _nodes5)
        {
            controller.SET_PATH_NODE(name, "Path_5");
        }
        else if (_currentPath == _nodes6)
        {
            controller.SET_PATH_NODE(name, "Path_6");
        }

        // STORE DATA ON THE NODE THE PLAYER IS CURRENTLY ON
        controller.SET_NODE_INDEX(name, _currentNode);

        // STORE DATA ON THE GLOBAL POSITION THE PLAYER IS CURRENTLY LOCATED
        controller.SET_END_POS(name, transform.position);
        controller.SET_POS_VECTOR(name, _currentPositionHolder);
    }
}
